% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thUtils.R
\name{fitCosine}
\alias{fitCosine}
\title{Fit cosine curves to multi-depth temperature time series}
\usage{
fitCosine(
  empiricalData,
  boundaryMean,
  periodInSeconds,
  optimizeRange,
  nmin,
  empiricalDataPeriods
)
}
\arguments{
\item{empiricalData}{A zoo object with one column per sensor depth.
Column names should correspond to sensor identifiers.}

\item{boundaryMean}{Numeric scalar — mean temperature at the boundary (degC).
Held fixed during fitting.}

\item{periodInSeconds}{Numeric scalar — period of the target cycle (s).
86400 for diel, 86400*365.25 for annual.}

\item{optimizeRange}{Numeric vector of length 2 — valid phase window as
fractions of the period relative to the boundary sensor phase.
Default c(-0.05, 1.05) allows slight negative phases and up to one
full period of lag.}

\item{nmin}{Integer — minimum number of non-NA observations required to
attempt fitting for a given sensor. Sensors below this threshold return
NA for amplitude and phase.}

\item{empiricalDataPeriods}{Numeric — number of complete cycles in the data.
Used for phase unwrapping in multi-period datasets (typically 1 for
standard analysis windows).}
}
\value{
A list with two components:
  \describe{
    \item{deltaPhaseRadians}{Numeric vector of length n^2 — pairwise phase
      differences (radians). Reshape with derived2DArray().}
    \item{ampRatio}{Numeric vector of length n^2 — pairwise amplitude ratios.
      Reshape with derived2DArray().}
  }
  Attributes:
  \describe{
    \item{amplitudes}{Named numeric vector — fitted amplitude per sensor.}
    \item{phases}{Named numeric vector — fitted phase per sensor (radians).}
  }
}
\description{
Uses nonlinear least squares (nls) to fit a cosine function to each sensor's
temperature data, extracting amplitude and phase. Returns pairwise amplitude
ratios and phase differences for all sensor combinations.
}
\details{
The fitted model at each depth is:
  T(t) = boundaryMean + A * cos((2*pi/period) * t - phi)

where A (amplitude) and phi (phase) are estimated by nls, and boundaryMean
and period are held fixed (known from the boundary condition).


**Negative amplitude handling:** nls may converge to a negative amplitude
with a phase offset. When this happens, the amplitude is negated and pi
radians is added to the phase (mathematically equivalent: -A*cos(t - phi) =
A*cos(t - phi - pi)).

**Phase wrapping:** Phases are adjusted relative to the boundary sensor's
phase to ensure consistent phase differences across depths. The
`optimizeRange` parameter defines the valid window (in periods) for phase
values relative to the boundary, and `empiricalDataPeriods` accounts for
multi-period datasets where deeper sensors may lag by more than one cycle.

**Noise injection for synthetic data:** When input data is a perfect cosine
(zero residuals), nls encounters a singular gradient and fails. A negligible
amount of noise (~0.01% of the mean) is added to prevent this. This has no
measurable effect on real data but enables round-trip validation with
synthetic signals.
}
